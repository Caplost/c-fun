{
  "1": {
    "id": 1,
    "title": "两数之和",
    "description": "\u003ch3\u003e【题目描述】\u003c/h3\u003e\u003cp\u003e给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。\u003c/p\u003e\u003cp\u003e你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两次。\u003c/p\u003e\u003ch3\u003e输入\u003c/h3\u003e\u003cp\u003e第一行为数组大小 n 和目标值 target，以空格分隔。\u003c/p\u003e\u003cp\u003e第二行为 n 个整数，表示数组 nums。\u003c/p\u003e\u003ch3\u003e输出\u003c/h3\u003e\u003cp\u003e输出为两个整数，分别为符合条件的两个数的下标（从0开始计数），以空格分隔。输出的下标可以是任意顺序。\u003c/p\u003e",
    "difficulty": "Easy",
    "time_limit": 1000,
    "memory_limit": 65536,
    "knowledge_tag": null,
    "created_at": "2025-02-27T19:52:22.572747+08:00"
  },
  "2": {
    "id": 2,
    "title": "回文数",
    "description": "\u003ch3\u003e【题目描述】\u003c/h3\u003e\u003cp\u003e判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\u003c/p\u003e\u003ch3\u003e输入\u003c/h3\u003e\u003cp\u003e一个整数 x。\u003c/p\u003e\u003ch3\u003e输出\u003c/h3\u003e\u003cp\u003e如果 x 是回文数，输出 true，否则输出 false。\u003c/p\u003e",
    "difficulty": "Easy",
    "time_limit": 500,
    "memory_limit": 32768,
    "knowledge_tag": null,
    "created_at": "2025-02-27T19:52:22.572766+08:00"
  },
  "3": {
    "id": 3,
    "title": "合并两个有序链表",
    "description": "\u003ch3\u003e【题目描述】\u003c/h3\u003e\u003cp\u003e将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\u003c/p\u003e\u003cp\u003e在这个题目中，我们使用数组来表示链表。\u003c/p\u003e\u003ch3\u003e输入\u003c/h3\u003e\u003cp\u003e第一行是第一个链表的元素，以空格分隔。如果链表为空，则输入为空行。\u003c/p\u003e\u003cp\u003e第二行是第二个链表的元素，以空格分隔。如果链表为空，则输入为空行。\u003c/p\u003e\u003ch3\u003e输出\u003c/h3\u003e\u003cp\u003e合并后的链表元素，以空格分隔。\u003c/p\u003e",
    "difficulty": "Medium",
    "time_limit": 800,
    "memory_limit": 49152,
    "knowledge_tag": null,
    "created_at": "2025-02-27T19:52:22.572774+08:00"
  },
  "4": {
    "id": 4,
    "title": "测试持久化",
    "description": "\u003ch3\u003e【题目描述】\u003c/h3\u003e\u003cp\u003e测试数据持久化功能\u003c/p\u003e\u003ch3\u003e输入\u003c/h3\u003e\u003cp\u003e一个整数\u003c/p\u003e\u003ch3\u003e输出\u003c/h3\u003e\u003cp\u003e输入的整数乘以2\u003c/p\u003e",
    "difficulty": "Easy",
    "time_limit": 1000,
    "memory_limit": 65536,
    "knowledge_tag": null,
    "created_at": "2025-02-27T19:52:42.635751+08:00"
  },
  "5": {
    "id": 5,
    "title": "题目标题1212",
    "description": "\u003ch3\u003e【题目描述】\u003c/h3\u003e\u003cp\u003e这是题目描述\u003c/p\u003e\u003ch3\u003e输入\u003c/h3\u003e\u003cp\u003e输入说明\u003c/p\u003e\u003ch3\u003e输出\u003c/h3\u003e\u003cp\u003e输出说明\u003c/p\u003e",
    "difficulty": "Easy",
    "time_limit": 1000,
    "memory_limit": 65536,
    "knowledge_tag": null,
    "created_at": "2025-02-27T19:55:57.734828+08:00"
  },
  "6": {
    "id": 6,
    "title": "示例题目",
    "description": "题目描述...",
    "difficulty": "Medium",
    "time_limit": 1000,
    "memory_limit": 65536,
    "knowledge_tag": null,
    "created_at": "2025-03-05T21:19:29.845835+08:00"
  },
  "7": {
    "id": 7,
    "title": "内存地址计算",
    "description": "在计算机系统中，内存地址的计算是一个基本但重要的操作。假设有一个计算机系统，其内存按字节编址，且内存地址从0开始。给定一个二维数组的起始地址和数组的维度，以及一个元素的行列索引，计算该元素的内存地址。\n\n输入格式:\n- 第一行包含三个整数：起始地址base（0 ≤ base ≤ 10^6），行数rows（1 ≤ rows ≤ 10^3），列数cols（1 ≤ cols ≤ 10^3）。\n- 第二行包含两个整数：目标元素的行索引row（0 ≤ row \u003c rows），列索引col（0 ≤ col \u003c cols）。\n\n输出格式:\n- 输出一个整数，表示目标元素的内存地址。\n\n注意：假设数组是按行优先顺序存储的。",
    "difficulty": "Medium",
    "time_limit": 1000,
    "memory_limit": 262144,
    "knowledge_tag": [
      "计算机基本构成",
      "内存地址计算"
    ],
    "created_at": "2025-03-06T11:44:12.68074+08:00"
  },
  "8": {
    "id": 8,
    "title": "进程调度模拟",
    "description": "在操作系统中，进程调度是一个核心概念。本题要求你模拟一个简单的进程调度器。给定一组进程，每个进程有一个到达时间和执行时间，你需要按照先来先服务（FCFS）的调度算法，计算每个进程的完成时间、周转时间和等待时间。\n\n输入格式:\n第一行包含一个整数n，表示进程的数量。\n接下来n行，每行包含两个整数，分别表示进程的到达时间和执行时间。\n\n输出格式:\n输出n行，每行包含三个整数，分别表示进程的完成时间、周转时间和等待时间。\n\n注意:\n- 进程按照到达时间的顺序进行处理。\n- 如果多个进程同时到达，按照输入顺序处理。",
    "difficulty": "Easy",
    "time_limit": 1000,
    "memory_limit": 262144,
    "knowledge_tag": [
      "计算机基本构成",
      "操作系统基本概念"
    ],
    "created_at": "2025-03-06T11:45:49.027769+08:00"
  }
}